# Vue.js 服务端渲染指南

> **注意:** 该指南要求的vue及其同伴库的最低版本如下:
> - vue & vue-server-renderer >= 2.3.0
> - vue-router >= 2.5.0
> - vue-loader >= 12.0.0 & vue-style-loader >= 3.0.0如果你之前使用过Vue2.2的服务端渲染，你应该注意到了之前代码和现在 [有一点不同](./structure.md) (将参数 [runInNewContext](./api.md#runinnewcontext) 设置为了 `false`)。你现有的应用程序仍然可以正常工作，但是建议你迁移到新的推荐方式上来。

## 什么是服务端渲染(SSR)？

Vue.js是构建客户端应用程序的框架。 默认情况下，Vue组件在浏览器中生成和操作DOM作为输出。 然而，也可以将相同的组件在服务器上通过HTML字符串呈现出来，然后将它们直接发送到浏览器，最后将静态标记“合成”为客户端上完全交互的应用程序。

服务器渲染的Vue.js应用程序也可以被认为是“同构”或“通用”，因为您的应用程序的大部分代码在服务器**和** 客户端上都能正常运行。

## 为什么要使用SSR?

与传统SPA（单页面应用）相比，SSR的优势主要在于：

- 更好的搜索引擎优化，搜索引擎抓取工具将直接抓取到完全在服务端呈现好的页面。

现在需要注意的是，Google和Bing可以对同步JavaScript应用程序进行索引。 同步在这里是个关键词。 如果您的应用程序首先加载框架，然后通过Ajax获取数据内容，搜素引擎的爬虫程序不会等待获取数据完成。 这意味着如果您在SEO重要的页面上异步获取内容时，则可能需要SSR。

- 更快的获取到内容，特别是在网速慢或这设备性能低的机器上。 服务器渲染的页面不需要等待所有的JavaScript都被下载并执行显示，所以你的用户将会更快地看到一个完全呈现的页面。 这通常是一个更好的用户体验，并且对于初始加载要求更快的相关的应用程序可能是至关重要的。

这里有些在使用SSR时需要权衡的地方：

- 开发限制 浏览器特定的代码只能在某些生命周期钩子中使用; 一些外部依赖库可能需要特殊处理才能在服务器渲染的应用程序中运行。
- 更多涉及构建设置和部署的要求。 与可以部署在任何静态文件服务器上的完全静态SPA不同，服务端渲染的应用程序需要一个Node.js服务器环境才可以运行。
- 更多的服务器端负载。 在Node.js中渲染完整的应用程序显然会比仅提供静态文件更多使用CPU，因此如果您期望高流量，请准备相应的服务器负载并明智地采用缓存策略。

在您的应用程序使用SSR之前，您应该问第一个问题是否真的需要它。 这主要取决于您的应用程序对于内容要求的重要性。 例如，如果您正在构建一个内部仪表板，初始加载的额外的几百毫秒并不是很重要，SSR将是一个过度的杀伤力。 然而，在初始加载要求更快获取内容的情况下，SSR可以帮助您实现最佳的初始负载性能。

## SSR vs 预加载

如果您只是通过 SSR 以改进少数营销页面 (例如， `/`, `/about`, `/contact`等)的SEO问题, 那么你可能需要 **预加载**。  而不是使用Web服务器即时编译HTML，而是在构建时简单地生成针对特定路由的静态HTML文件。 这样做的优点是设置预加载更简单，并允许你将你的前端作为一个完全静态的站点。

如果你使用Webpack构建，你能很容易的通过Webpack的 [prerender-spa-plugin](https://github.com/chrisvfritz/prerender-spa-plugin)插件添加预加载。 它已经被 Vue 应用程序广泛测试 ，事实上 [创建者](https://github.com/chrisvfritz) 是Vue核心团队的成员。

## 关于这个指南

该指南专注于使用Node.js作为服务器的服务器渲染的单页面应用程序。 将Vue SSR与其他后端设置进行混合是其自身的一个主题，该指南不包括在内。

本指南讲解非常深入，并且假设您已经熟悉Vue.js本身，并且具有Node.js和Webpack的相关知识。 如果您喜欢更平滑的开箱即用体验的更高级别的解决方案，那么您应该尝试[Nuxt.js](http://nuxtjs.org/) 。 它建立在相同的Vue技术栈上，但抽象出很多样板，并提供了一些额外的功能，如静态站点生成。 但是，如果您需要更直接地控制应用程序的结构，则可能无法适应用例。 无论如何，阅读本指南将更有助于更好地了解事情如何协同工作。

当您阅读时，参考官方[HackerNews Demo](https://github.com/vuejs/vue-hackernews-2.0/)实例将对你有所帮助，该实例利用了本指南涵盖的大部分技术。

最后，请注意，本指南中的解决方案不是一成不变的，目前我们发现这对我们来说可能是最好的，但这并不意味着它们不能被改进。 它们可能会在未来被修改代替，并通过提交 pull requests 自由作出贡献！
